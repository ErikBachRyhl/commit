// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// NextAuth models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts      Account[]
  sessions      Session[]
  repos         RepoLink[]
  settings      Settings?
  runs          ProcessingRun[]
  jobs          Job[]
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Application models
model RepoLink {
  id             String  @id @default(cuid())
  userId         String
  user           User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  provider       String  // 'github'
  owner          String
  repo           String
  defaultBranch  String  @default("main")
  yamlPath       String  @default("commit.yml")
  lastSyncedSha  String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  runs           ProcessingRun[]

  @@unique([userId, owner, repo])
}

model Settings {
  id        String   @id @default(cuid())
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Normalized fields that mirror YAML
  courses   Json     // [{key, title, paths, deck}]
  llm       Json     // {provider, model, temperature, maxTokens, enabled, etc}
  parsing   Json     // {envsToExtract, neighborContextLines, etc}
  cards     Json     // {dailyNewLimit, priorities, tags}
  rawYaml   String?  @db.Text // Original YAML text for round-trip
  
  // Dev mode for testing features
  devMode   Boolean  @default(false)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Job Queue System
model Job {
  id              String    @id @default(uuid())
  type            String    // 'reprocess', 'audit', etc.
  selector        Json      // {commit_ids: [...]} or {course_id: ...}
  force           Boolean   @default(false)
  idempotencyKey  String?   // hash(type+selector) when !force
  status          String    @default("queued") // queued|running|done|failed|cancelled
  createdBy       String
  createdAt       DateTime  @default(now())
  startedAt       DateTime?
  finishedAt      DateTime?
  error           String?   @db.Text
  
  user            User      @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  commitRuns      CommitRun[]
  
  @@unique([idempotencyKey], map: "unique_active_jobs")
  @@index([status, createdAt])
  @@map("jobs")
}

model CommitRun {
  id               String   @id @default(uuid())
  commitSha        String
  pipelineVersion  String   // e.g. "parser-1.1/card-v2"
  runVersion       String   @default(uuid())
  jobId            String?
  status           String   // success|failed|skipped|running
  artifactUri      String?
  metrics          Json?    // {blocks: 31, cards: 62, tokens: ...}
  createdAt        DateTime @default(now())
  
  job              Job?     @relation(fields: [jobId], references: [id], onDelete: SetNull)
  
  @@unique([commitSha, pipelineVersion, runVersion])
  @@index([commitSha, pipelineVersion, status])
  @@map("commit_runs")
}

model ProcessingRun {
  id          String    @id @default(cuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  repoId      String?
  repo        RepoLink? @relation(fields: [repoId], references: [id], onDelete: SetNull)
  
  commitSha   String?
  status      String    // 'queued' | 'running' | 'succeeded' | 'failed'
  logs        Json      @default("[]") // [{ts, level, msg}]
  
  startedAt   DateTime?
  endedAt     DateTime?
  createdAt   DateTime  @default(now())
  
  // Stats from CLI output
  filesProcessed  Int?
  blocksExtracted Int?
  notesCreated    Int?
  notesUpdated    Int?
  notesSkipped    Int?
  
  // Artifact paths
  apkgPath    String?
  
  suggestions CardSuggestion[]
}

model CardSuggestion {
  id          String         @id @default(cuid())
  runId       String
  run         ProcessingRun  @relation(fields: [runId], references: [id], onDelete: Cascade)
  
  idx         Int            // Order in the run
  front       String         @db.Text
  back        String         @db.Text
  tags        String[]
  cardType    String         @default("basic") // 'basic' | 'cloze'
  sourceFile  String?
  sourceLine  Int?
  state       String         @default("pending") // 'pending' | 'accepted' | 'discarded'
  metadata    Json?          // Additional metadata from LLM
  
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  
  actions     CardAction[]

  @@index([runId, state])
}

model CardAction {
  id           String         @id @default(cuid())
  suggestionId String
  suggestion   CardSuggestion @relation(fields: [suggestionId], references: [id], onDelete: Cascade)
  
  action       String         // 'add' | 'discard' | 'recreate'
  payload      Json?          // Additional action data
  createdAt    DateTime       @default(now())
}
